## 前言

线段树能实现的功能**完全包含**树状数组，然而树状数组的代码简短且十分好写，貌似常数也会小一点

一点建议就是代码一定要完完全全自己写一遍，加深印象，还能发现细节问题，还有潜在的理解问题



这两个数据结构主要是干这个事情的:
**单点修改区间查询** (每次操作 o(logn))
**区间修改区间查询** (每次操作 o(logn))
时间复杂度比 o(n) 优秀很多



线段树：基于分治思想的二叉树用来维护区间信息，可以用O(logn)的时间复杂度内实现单点修改、区间修改、区间查询等操作。线段树每个叶子节点存储元素本身，非叶子节点存储区间内元素的统计值。



## 树状数组 (Binary Indexed Tree | Fenwick Tree)

**可以:** `O(logn)` **单点修改** & `O(logn)` **区间求和**
比如查数组 `a` 的 `[l, r]` 的区间和，或者让 `a[x] += v`

树状数组的特性可以从下面的图来理解

![image-20260128014216617](./../AppData/Roaming/Typora/typora-user-images/image-20260128014216617.png)

树状数组下标一般从 1 开始

**树状数组有一个神奇的特性：**节点 i 管辖的长度为 **lowbit(i)**
${lowbit}$ 为最低位的 1 的大小 , 如 lowbit(00110**1**0) = 2 , lowbit(01**1**00) = 4
`lowbit(i) = i & -i`

**第一步**首先是求前缀和
**然后**差分思想，用前缀和的求区间和



### 参考资料

[**可视化视频**](https://www.bilibili.com/video/BV1ce411u7qP) 5 min

[**OI-WIKI讲解**](**https://oi-wiki.org/ds/fenwick/**)

### 参考代码

```cpp
struct BIT{
    int n;
    vector<ll> tree;
    // 初始化
    void init(int n_){
        n = n_;
        tree = vector<ll>(n + 1);
    }
    // a[x] += v
    void add(int x, ll v){
        for(int i=x; i<=n; i+=i&-i){
            tree[i] += v;
        }
    }
    // 查前缀和 a[1, x]
    ll query(int x){
        ll ans = 0;
        for(int i=x; i>=1; i-=i&-i){
            ans += tree[i];
        }
        return ans;
    }
    // query [x, y]
    ll query(int x, int y){
        return query(y) - query(x - 1);
    }
};
```

**例题:** [P3374 树状数组1](https://www.luogu.com.cn/problem/P3374)



#### 树状数组求逆序对

**例题**: [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

```c++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

constexpr int inf = 0x3f3f3f3f;

struct BIT{
    int n;
    vector<ll> tree;
    void init(int n_){
        n = n_;
        tree = vector<ll>(n + 1);
    }
    void add(int x, ll v){
        for(int i=x; i<=n; i+=i&-i){
            tree[i] += v;
        }
    }
    ll query(int x){
        ll ans = 0;
        for(int i=x; i>=1; i-=i&-i){
            ans += tree[i];
        }
        return ans;
    }
    ll query(int x, int y){
        return query(y) - query(x - 1);
    }
};

void solve(){
    int n; 
    cin >> n;
    vector<ll> a(n + 1);
    for(int i=1; i<=n; i++){
        cin >> a[i];
    }
    // 离散化
    auto tmp = a;
    sort(tmp.begin()+1, tmp.end());
    tmp.erase(unique(tmp.begin()+1, tmp.end()), tmp.end());
    for(int i=1; i<=n; i++){
        a[i] = lower_bound(tmp.begin()+1, tmp.end(), a[i]) - tmp.begin();
    }

    // 求逆序对数量
    BIT bit;
    bit.init(n);
    ll ans = 0;
    for(int i=1; i<=n; i++){
        ans += bit.query(a[i]+1, n);
        bit.add(a[i], 1);
    }
    cout << ans << '\n';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int t = 1; //cin >> t;
    while(t--) solve();
    
    return 0;
}
```



**补充知识点: 离散化**
离散化的目的就是让元素更紧凑一点

**例题** [U232423 离散化](https://www.luogu.com.cn/problem/U232423)

```cpp
// 用二分找当前是第几大来离散化
void solve(){
    int n; 
    cin >> n;
    vector<ll> a(n + 1);
    for(int i=1; i<=n; i++){
        cin >> a[i];
    }
    auto tmp = a;
    sort(tmp.begin()+1, tmp.end());
    tmp.erase(unique(tmp.begin()+1, tmp.end()), tmp.end());
    for(int i=1; i<=n; i++){
        a[i] = lower_bound(tmp.begin()+1, tmp.end(), a[i]) - tmp.begin();
    }
    for(int i=1; i<=n; i++){
        cout << a[i] << " \n"[i == n];
    }
}
```

比如 `5 10 2 2 1 3` 
可以离散化成 `4 5 2 2 1 3`



## 线段树 (SegmentTree)

就是一棵树，每个节点都负责一段儿信息

比如：节点 p -> a[l, r]的和

#### 简单线段树

**可以:** `O(logn)`**单点修改** + `O(logn)` **区间求和**

![image-20260128024505124](./../AppData/Roaming/Typora/typora-user-images/image-20260128024505124.png)

##### 参考代码

```cpp
struct SegTree{
    int n;
    vector<ll> a;
    vector<ll> sum;

    #define lp (p << 1)
    #define rp (p << 1 | 1)
    
    // 构造/初始化函数
    void init(int n_){
        n = n_;
        sum = vector<ll>(n+1 << 2);
    }
    void init(int n_, auto& a_){
        n = n_; a = a_;
        sum = vector<ll>(n+1 << 2);
        build(1, 0, n);
    }

    void pull(int p){
        sum[p] = sum[lp] + sum[rp];
    }
    
    void build(int p, int l, int r){
        if(l == r){
            sum[p] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(lp, l, mid);
        build(rp, mid+1, r);
        pull(p);
    }
    
    // 单点修改
    void update(int p, int l, int r, int x, ll v){ 
        if(l == r){
            sum[p] += v;
            return;
        }

        int mid = l + r >> 1;
        if(x <= mid) update(lp, l, mid, x, v);
        else update(rp, mid + 1, r, x, v);
        pull(p);
    }

    // 区间查询
    ll query(int p, int l, int r, int x, int y){
        if(x <= l && r <= y) return sum[p];

        ll ans = 0;
        int mid = (l + r) >> 1;

        if(x <= mid) ans += query(lp, l, mid, x, y);
        if(y >= mid + 1) ans += query(rp, mid + 1, r, x, y);

        return ans;
    }

    // 相当于是对外接口吧，外面调用时候可以少写一点
    void update(int x, ll v){ update(1, 0, n, x, v); } // 单点修改
    ll query(int L, int R){ return query(1, 0, n, L, R); } // 区间查询
};
```

**例题:** [P3374 树状数组](https://www.luogu.com.cn/problem/P3374) (假装题名叫线段树)

#### 线段树单点修改区间求最值

```cpp
struct SegTree{
    int n;
    vector<int> a;
    vector<ll> mi, ma;

    #define lp (p << 1)
    #define rp (p << 1 | 1)
    
    // 构造/初始化函数
    void init(int n_){
        n = n_;
        mi = vector<ll>(n+1 << 2, inf);
        ma = vector<ll>(n+1 << 2, -inf);
    }
    void init(int n_, auto& a_){
        n = n_; a = a_;
        mi = vector<ll>(n+1 << 2, inf);
        ma = vector<ll>(n+1 << 2, -inf);
        build(1, 0, n);
    }

    void pull(int p){
        mi[p] = min(mi[lp], mi[rp]);
        ma[p] = max(ma[lp], ma[rp]);
    }
    
    void build(int p, int l, int r){
        if(l == r){
            ma[p] = mi[p] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(lp, l, mid);
        build(rp, mid+1, r);
        pull(p);
    }
    
    // 单点修改
    void update(int p, int l, int r, int x, ll v){ 
        if(l == r){
            ma[p] += v;
            mi[p] += v;
            return;
        }

        int mid = l + r >> 1;
        if(x <= mid) update(lp, l, mid, x, v);
        else update(rp, mid + 1, r, x, v);
        pull(p);
    }

    // 区间查询
    ll queryMA(int p, int l, int r, int x, int y){
        if(x <= l && r <= y) return ma[p];

        ll ans = -inf;
        int mid = (l + r) >> 1;

        if(x <= mid) ans = max(ans, queryMA(lp, l, mid, x, y));
        if(y >= mid + 1) ans = max(ans, queryMA(rp, mid + 1, r, x, y));

        return ans;
    }
    ll queryMI(int p, int l, int r, int x, int y){
        if(x <= l && r <= y) return mi[p];

        ll ans = inf;
        int mid = (l + r) >> 1;

        if(x <= mid) ans = min(ans, queryMI(lp, l, mid, x, y));
        if(y >= mid + 1) ans = min(ans, queryMI(rp, mid + 1, r, x, y));

        return ans;
    }

    // 相当于是对外接口吧，外面调用时候可以少写一点
    void update(int x, ll v){ update(1, 0, n, x, v); } // 单点修改
    ll queryMA(int L, int R){ return queryMA(1, 0, n, L, R); } // 区间查询
    ll queryMI(int L, int R){ return queryMI(1, 0, n, L, R); } // 区间查询
};
```

**例题: **[P4392 静音问题](https://vjudge.net/problem/洛谷-P4392/origin)



#### **懒标记线段树**

**可以:** **区间加 + 区间查**

线段树有很多模块，写什么模块就有什么功能

**例题: ** [P3372 线段树模板 1](https://www.luogu.com.cn/problem/P3372)

##### 参考代码

```cpp
struct SegTree{
    int n;
    vector<ll> a; 
    vector<ll> add; // tag - 懒标记数组
    vector<ll> sum; // info - 维护的信息

    #define lp (p << 1)
    #define rp (p << 1 | 1)
    #define lk (mid - l + 1)
    #define rk (r - mid)
    
    // 构造/初始化函数
    void init(int n_){
        n = n_;
        sum = add = vector<ll>(n+1 << 2);
    }
    void init(int n_, auto& a_){
        n = n_; a = a_;
        sum = add = vector<ll>(n+1 << 2);
        build(1, 0, n);
    }

    // lazy 打上标记
    void lazy(int p, int k, ll v){
        sum[p] += 1ll * k * v;
        add[p] += v;
    }
    // 从子节点获取最新信息
    void pull(int p){
        sum[p] = sum[lp] + sum[rp];
    }
    // push 懒信息
    void push(int p, int l, int r){
        if(add[p] == 0) return;
        int mid = l + r >> 1;
        lazy(lp, lk, add[p]);
        lazy(rp, rk, add[p]);
        add[p] = 0;
    }
    // build 初始化线段树
    void build(int p, int l, int r){
        if(l == r){
            sum[p] = a[l]; // return
            return;
        }
        int mid = (l + r) >> 1;
        build(lp, l, mid);
        build(rp, mid+1, r);
        pull(p);
    }
    
    // 区间修改
    void update(int p, int l, int r, int x, int y, ll v){
        if(x <= l && r <= y){
            lazy(p, r - l + 1, v);
            return;
        }

        int mid = l + r >> 1;
        push(p, l, r);
        if(x <= mid) update(lp, l, mid, x, y, v);
        if(y >= mid + 1) update(rp, mid + 1, r, x, y, v);
        pull(p);
    }
    // 区间查询
    ll query(int p, int l, int r, int x, int y){
        if(x <= l && r <= y) return sum[p];

        ll ans = 0;
        int mid = (l + r) >> 1;
        push(p, l, r);

        if(x <= mid) ans += query(lp, l, mid, x, y);
        if(y >= mid + 1) ans += query(rp, mid + 1, r, x, y);

        return ans;
    }

    // 相当于是对外接口吧，外面调用时候可以少写一点
    void update(int x, ll v){ update(1, 0, n, x, v); } // 单点修改
    void update(int L, int R, ll v){ update(1, 0, n, L, R, v); } // 区间更新
    ll query(int L, int R){ return query(1, 0, n, L, R); } // 区间查询
};
```



###### 扩展

另外若不要求实时查询某位置的值, 差分可以 O(1) 实现区间加

差分扩展: [等差数列](https://amiracle.site/2025/09/02/%E4%BA%8C%E9%98%B6%E5%B7%AE%E5%88%86/)
