### [A - P1774 最接近神的人](https://www.luogu.com.cn/problem/P1774)

每交换一次逆序对数量减 1，于是转化成求逆序对的问题

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// BIT | Fenwick
struct BIT{
	int n;
	vector<ll> tree;
	void init(int _n){
		n = _n;
		tree = vector<ll>(n + 1);
	}
	void add(int x, ll k){
		for(int i=x; i<=n; i+=i&-i){
			tree[i] += k;
		}
	}
	ll query(int x){
		ll ans = 0;
		for(int i=x; i>=1; i-=i&-i){
			ans += tree[i];
		}
		return ans;
	}
	// 差分求[x, y]区间和 
	ll query(int x, int y){
		if(x > y) return 0;
		return query(y) - query(x-1);
	}
};

int main(){
	int n;
	cin >> n;
	vector<int> a(n + 1);
	for(int i=1; i<=n; i++){
		cin >> a[i];
	}
	
	// 离散化 - 把 ai 范围离散到 [1, n] 
   auto tmp = a;
    sort(tmp.begin()+1, tmp.end());
    tmp.erase(unique(tmp.begin()+1, tmp.end()), tmp.end());
    for(int i=1; i<=n; i++){
        a[i] = lower_bound(tmp.begin()+1, tmp.end(), a[i]) - tmp.begin();
    }

	BIT bit;
	bit.init(n);
	
	ll ans = 0;
	for(int i=1; i<=n; i++){
		int cnt = bit.query(a[i]+1, n);
		ans += cnt;
		bit.add(a[i], 1);
	}
	cout << ans << '\n';	
}
```



### [B - P5149 会议座位](https://www.luogu.com.cn/problem/P5149)

求逆序对裸题，用 map 映射一下数字即可

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// BIT | Fenwick
struct BIT{
	int n;
	vector<ll> tree;
	void init(int _n){
		n = _n;
		tree = vector<ll>(n + 1);
	}
	void add(int x, ll k){
		for(int i=x; i<=n; i+=i&-i){
			tree[i] += k;
		}
	}
	ll query(int x){
		ll ans = 0;
		for(int i=x; i>=1; i-=i&-i){
			ans += tree[i];
		}
		return ans;
	}
	// 差分求[x, y]区间和 
	ll query(int x, int y){
		if(x > y) return 0;
		return query(y) - query(x-1);
	}
};

int main(){
	int n;
	cin >> n;
    
    map<string, int> mp;
    for(int i=1; i<=n; i++){
        string s;
        cin >> s;
        mp[s] = i;
    }

    vector<int> a(n + 1);
	for(int i=1; i<=n; i++){
        string s;
        cin >> s;
        a[i] = mp[s];
    }

	BIT bit;
	bit.init(n);
	
	ll ans = 0;
	for(int i=1; i<=n; i++){
		int cnt = bit.query(a[i]+1, n);
		ans += cnt;
		bit.add(a[i], 1);
	}
	cout << ans << '\n';
	
}
```



### [C - P2068 统计和](https://www.luogu.com.cn/problem/P2068)

单点加区间求和裸题，树状数组线段树都行

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// BIT | Fenwick
struct BIT{
	int n;
	vector<ll> tree;
	void init(int _n){
		n = _n;
		tree = vector<ll>(n + 1);
	}
	void add(int x, ll k){
		for(int i=x; i<=n; i+=i&-i){
			tree[i] += k;
		}
	}
	ll query(int x){
		ll ans = 0;
		for(int i=x; i>=1; i-=i&-i){
			ans += tree[i];
		}
		return ans;
	}
	// 差分求[x, y]区间和 
	ll query(int x, int y){
		return query(y) - query(x-1);
	}
};

int main(){
	int n, m;
	cin >> n >> m;
	
	BIT bit;
	bit.init(n);
	
	for(int i=1; i<=n; i++){
		int x; cin >> x;
		bit.add(i, x);
	}
	
	for(int i=1; i<=m; i++){
		int op; cin >> op;
		if(op == 'x'){
			int x; ll k;
			cin >> x >> k;
			bit.add(x, k);
		}
		if(op == 'y'){
			int x, y;
			cin >> x >> y;
			cout << bit.query(x, y) << '\n';
		}
	}
	
}
```

### [D - 中位数](https://www.luogu.com.cn/problem/P1168)

这题貌似出过多次，使用对顶堆或者用set移动迭代器都可以是 **o(nlogn)** 的做法

这里提供一个在树状数组上二分的方法，~~虽然复杂度是 o(nlog^2)~~ (但其实也可以是 nlog)

具体来说就是去二分**第 (i+1)/2 大**就行

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

// BIT | Fenwick
struct BIT{
	int n;
	vector<ll> tree;
	void init(int _n){
		n = _n;
		tree = vector<ll>(n + 1);
	}
	void add(int x, ll k){
		for(int i=x; i<=n; i+=i&-i){
			tree[i] += k;
		}
	}
	ll query(int x){
		ll ans = 0;
		for(int i=x; i>=1; i-=i&-i){
			ans += tree[i];
		}
		return ans;
	}
	// 差分求[x, y]区间和 
	ll query(int x, int y){
		if(x > y) return 0;
		return query(y) - query(x-1);
	}
};

int main(){
	int n;
	cin >> n;
	vector<int> a(n + 1);
	for(int i=1; i<=n; i++){
		cin >> a[i];
	}
    
	// 离散化 - 把 ai 范围离散到 [1, n] 
    auto tmp = a;
    sort(tmp.begin()+1, tmp.end());
    tmp.erase(unique(tmp.begin()+1, tmp.end()), tmp.end());
    for(int i=1; i<=n; i++){
        a[i] = lower_bound(tmp.begin()+1, tmp.end(), a[i]) - tmp.begin();
    }

	BIT bit;
	bit.init(n);
	
    // nlog^2
	for(int i=1; i<=n; i++){
        bit.add(a[i], 1);
        if(i & 1){
            int lo = 0, hi = n+1;
            while(lo + 1 != hi){
                int mid = lo + hi >> 1;
                if(bit.query(mid) < (i+1)/2) lo = mid;
                else hi = mid;
            }
            // cout << hi << endl;
            cout << tmp[hi] << '\n';
        }
	}
}
```



这题好像还有神秘做法，如下，不过时间复杂度是错的**O(n^2 + nlogn)**，因为 vec 的插入是 O(n)，感觉是数据水了

```cpp
#include <bits/stdc++.h> 
using namespace std;
using ll=long long;
int main(){
	int n;
	cin>>n;
	vector<int> nums;
	for(int i=0; i<n; i++){
		int num;
		cin>>num;
		auto it = lower_bound(nums.begin(), nums.end(), num);
		nums.insert(it, num);
		if(i%2==0) cout<<nums[i/2]<<endl;
	}
}
```



### [E - P2880 [USACO07JAN] Balanced Lineup G](https://www.luogu.com.cn/problem/P2880)

**单点修改区间最值**裸题

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const ll inf = 3e18;
struct SegTree{
    int n;
    vector<int> a;
    vector<ll> ma, mi; // p - [l, r]    ma[p] -> a[l, r] 的区间最值 
	
    #define lp (p << 1)
    #define rp (p << 1 | 1)
    
    // 构造/初始化函数
    void init(int n_){
        n = n_;
        ma = vector<ll>(n+1 << 2, -inf);
        mi = vector<ll>(n+1 <<2, inf);
    }
    void init(int n_, auto& a_){
        n = n_; a = a_;
        ma = vector<ll>(n+1 << 2, -inf);
        mi = vector<ll>(n+1 <<2, inf);
        build(1, 0, n);
    }

    void pull(int p){
//        sum[p] = sum[lp] + sum[rp];
		ma[p] = max(ma[lp], ma[rp]);
		mi[p] = min(mi[lp], mi[rp]); 
    }
    
    void build(int p, int l, int r){
        if(l == r){
//            sum[p] = a[l];
			mi[p] = ma[p] = a[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(lp, l, mid);
        build(rp, mid+1, r);
        pull(p);
    }
    
    // 单点修改 a[x] + v
    void update(int p, int l, int r, int x, ll v){ 
        if(l == r){
//            sum[p] += v;
            mi[p] += v;
            ma[p] += v;
            return;
        }
		
        int mid = l + r >> 1;
        if(x <= mid) update(lp, l, mid, x, v);
        else update(rp, mid + 1, r, x, v);
        pull(p);
    }

	// 查 [x, y] 的最大值 
    ll queryMA(int p, int l, int r, int x, int y){
        if(x <= l && r <= y) return ma[p];

        ll ans = -inf;
        int mid = (l + r) >> 1;

        if(x <= mid) ans = max(ans, queryMA(lp, l, mid, x, y));
        if(y >= mid + 1) ans = max(ans, queryMA(rp, mid + 1, r, x, y));

        return ans;
    }
    ll queryMI(int p, int l, int r, int x, int y){
        if(x <= l && r <= y) return mi[p];

        ll ans = inf;
        int mid = (l + r) >> 1;

        if(x <= mid) ans = min(ans, queryMI(lp, l, mid, x, y));
        if(y >= mid + 1) ans = min(ans, queryMI(rp, mid + 1, r, x, y));

        return ans;
    }

    // 相当于是对外接口吧，外面调用时候可以少写一点
    void update(int x, ll v){ update(1, 0, n, x, v); } // 单点修改
    ll queryMA(int L, int R){ return queryMA(1, 0, n, L, R); }
    ll queryMI(int L, int R){ return queryMI(1, 0, n, L, R); }
//    ll query(int L, int R){ return query(1, 0, n, L, R); } // 区间查询
};

int main(){
    int n, q;
    cin >> n >> q;
    vector<int> a(n + 1);
    for(int i=1; i<=n; i++){
		cin >> a[i];
	}
	
	SegTree sgt;
	sgt.init(n, a);
	
	vector<int> ans;
    for(int i=1; i<=q; i++){
        int l, r;
        cin >> l >> r;
        cout << sgt.queryMA(l, r) - sgt.queryMI(l, r) << '\n';
	}
}
```

